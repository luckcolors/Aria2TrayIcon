package main
import "fmt"
import "bytes"
import "os"
import "os/exec"
import "net/http"
import "io/ioutil"
import "encoding/json"
import "github.com/paked/configure"
import "github.com/luckcolors/systray"
import "github.com/labstack/echo"
import "github.com/labstack/echo/engine/fasthttp"

var conf = configure.New()
var command = conf.String("command", "", "Command to execute")
var args  = conf.String("args", "", "Arguments for the command")
var iconFile = conf.String("iconFile", "", "Icon file to use")
var aria2Token = conf.String("aria2Token", "", "Secret key used for communicating with the aria2 rpc")
var aria2RpcUrl = conf.String("aria2RpcUrl", "", "Aria2 rpc Url")
var runHttpServer = conf.Bool("runHttpServer", false, "Wheter to run the webui web server or not")
var httpDataFolder = conf.String("httpDataFolder", "", "Name of the folder containing the files for the webui server")
var httpServerHost = conf.String("httpServerHost", "", "Address and port number on wich the webui server will listen on")
var osOpenHttp = conf.Bool("osOpenHttp", false, "Wheter to automatically open the browser on the webui url")
var osOpenHttpUrl = conf.String("osOpenHttpUrl", "", "Url to open, this should be the same as the one on wich the webui server is listening")
var osOpenHttpUrlCommand = conf.String("osOpenHttpUrlCommand", "", "Command used to open the url for the webui server")
var osOpenHttpUrlCommandArgs = conf.String("osOpenHttpUrlCommandArgs", "", "Arguments to pass to the command to open the url for the webui server")
var iconData []byte

// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
type Payload struct {
	Jsonrpc string `json:"jsonrpc"`
	ID string `json:"id"`
	Method string `json:"method"`
	Params []string `json:"params"`
}

func checkError(err error) {
  if err != nil {
    fmt.Println(err.Error())
    }
}

func initialization() {
  conf.Use(configure.NewJSONFromFile("./aria2TrayIconConf.json"))
  conf.Use(configure.NewEnvironment())
  conf.Parse()
  if *runHttpServer == true {
      go runHttpServerThread()
      if *osOpenHttp == true {
        osOpenUrl()
    }
  }
  go systray.Run(onReady)
}

func exit() {
	systray.Quit()
	os.Exit(0)
}

func runHttpServerThread() {
	e := echo.New()
	e.Static("/", *httpDataFolder)
	e.Run(fasthttp.New(*httpServerHost))
}

func osOpenUrl() {
	openUrl := exec.Command(*osOpenHttpUrlCommand, *osOpenHttpUrlCommandArgs + " " + *osOpenHttpUrl)
	err := openUrl.Start()
	checkError(err)
}

func onReady() {
  iconData, err := ioutil.ReadFile(*iconFile)
  checkError(err)
  systray.SetIcon(iconData)
  systray.SetTitle("Aria2 Deamon Tray Icon")
  systray.SetTooltip("Aria2")
  mQuit := systray.AddMenuItem("Quit", "Send to aria2 the Quit command")
  go func() {
     <-mQuit.ClickedCh
     rpcQuery("aria2.shutdown")
 }()
 mForceQuit := systray.AddMenuItem("Force Quit", "Send to aria2 the force quit command (it forcefully terminates it)")
 go func() {
    <-mForceQuit.ClickedCh
    rpcQuery("aria2.forceShutdown")
 }()
}

func rpcQuery(method string) {
  data := Payload {
  	Jsonrpc: "2.0",
    ID: "systray",
    Method: method,
  }
	data.Params = make([]string, 0)
	data.Params = append(data.Params, "token:" + *aria2Token)
  payloadBytes, err := json.Marshal(data)
  checkError(err)
  fmt.Println(string(payloadBytes))
  body := bytes.NewReader(payloadBytes)

  req, err := http.NewRequest("POST", *aria2RpcUrl, body)
  checkError(err)
  req.Header.Set("Content-Type", "application/json")
  req.Header.Set("Accept", "application/json")

  resp, err := http.DefaultClient.Do(req)
  fmt.Println(resp)
  checkError(err)
  defer resp.Body.Close()
}

func main() {
  initialization()
	cmd := exec.Command(*command, *args)
	err := cmd.Start()
	checkError(err)
	err = cmd.Wait()
	checkError(err)
	exit()
}
